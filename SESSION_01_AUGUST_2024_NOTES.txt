What is Programming Lang?
--------------------------------
-> A programming language is a way for humans to communicate instructions to a computer. 
It's like a set of rules and symbols that lets us tell the computer what to do, 
whether that's 
   - solving a math problem, 
	- displaying a webpage,
	- controlling a robot

-> A program is set of instructions aim to do particular task. 

-> A Language is set of grammatical & vocabulary rules to 
form correct & efficient instructions.

TYPES
=============
=> MACHINE LANGUAGE 
	- programs written using binary codes (0s and 1s) that a computer's CPU directly understands.
	- Low-level, hardware-specific.
	- Very difficult for humans to read and write; mainly understandable by computers.
	- Example: Specific binary instructions like 11010001 
	that perform operations like arithmetic or data movement.
=> ASSEMBLY LEVEL LANGUAGE
	- Uses symbolic names and mnemonics to represent machine code instructions.
	- Close to hardware, but more readable than machine language.
	- Easier for humans to read and write compared to machine language, using symbols and names instead of binary.
	- Example: Instructions like MOV AX, 1 (move the value 1 into register AX).
	
=> HIGH LEVEL LANGUAGE
	- A programming language that is more abstract and closer to human languages, designed to be easier to write and understand.
	- Much easier for humans to read and write; includes constructs like variables, loops, and functions.
	- Example: Languages like Python, Java, and C++ that use syntax and constructs familiar to human logic.
	
What is JAVA ?
===================
- A high-level, object-oriented programming language and 
   platform designed to be portable, secure, and robust.
- Created by Sun Microsystems (now owned by Oracle) in 1995. more than 3 billion devices run Java
- It is used for:
    Mobile applications (specially Android apps)
    Desktop applications
    Web applications
    Web servers and application servers Games
    Database connection

History
================
- At First Java was developed only for portable devices.
- Started as Green Project in 1991 with team (Green team) of 3 people (Gosling, Sheridan, Patrick)
- Sun Microsystems released its first public implementation in 1995-1996 as Java 1.0
- Initially they have named as "OAK" (national tree of USA) but due to copy rights issue, changed to JAVA (name of an island in indonesia where first coffee produced) 

Java Terminology
=====================
JDK: Java Development Kit
	- A software development kit used for developing Java applications.
	- Provides tools for writing, compiling, and debugging Java code.
	- JRE + additional tools like the Java compiler (javac) and debugging utilities.
	- JDK platform depedent 
	
JRE: Java Runtime Environment
	- It is a software layer that runs on top of a computerâ€™s OS software 
	and provides the class libraries and other resources that a specific Java program needs to run
	- A package that provides everything needed to run Java applications.
	- Includes: The Java Virtual Machine (JVM), core libraries, and other components required to execute Java programs.
	- Who Uses It: End-users who want to run Java programs but do not need to write or compile Java code.
JVM: Java Virtual Machine 
	- A virtual machine that runs Java bytecode (compiled Java code) and provides a platform-independent execution environment.
	- The core part of the JRE responsible for executing Java programs
	- Purpose: Converts Java bytecode into machine-specific code so it can be executed by the hardware.

In short:
    JDK: The full kit for Java development.
    JRE: The package to run Java applications.
    JVM: The engine that executes Java bytecode.

Bytecode
	- A set of instructions generated by the Java compiler that the Java Virtual Machine (JVM) can understand and execute.
	- Intermediate code, not directly executed by the hardware but by the JVM.
	- Allows Java programs to be portable and run on any device with a JVM, regardless of the underlying hardware.
	- Compiled Java code in a file with a .class extension.
	
ClassPath
	- A path or set of paths that the Java runtime 
	 uses to locate classes and libraries needed by a Java program.
	- Can be a directory or a list of directories and JAR files.
	- Helps the JVM and Java compiler find the classes and resources your program needs to run.
	- Setting the CLASSPATH environment variable or 
	using the -cp option in the command line to specify where to find your .class files or JAR files.

Garbage Collector
	-  A part of the Java runtime that automatically manages memory by freeing up space occupied by objects that are no longer needed.
	-  Runs in the background, cleaning up unused objects and helping to prevent memory leaks.

Bytecode: 
   Intermediate code run by the JVM, making Java programs portable.
ClassPath: 
  Path used to locate Java classes and libraries needed for your program.
Garbage Collector: 
   Automatic memory management tool that cleans up unused objects to free up memory.

Java Features 
----------------------
Platform Independence: Write Once, Run Anywhere (WORA) on any device with a JVM.
Object-Oriented: Uses objects and classes to promote modularity and code reuse.
Simple: Simplifies programming by removing complex features of other languages like pointers.
Secure: Provides a secure execution environment with features like bytecode verification.
Robust: Includes strong type checking, exception handling, and automatic memory management.
Multithreaded: Supports concurrent execution of multiple threads for better performance.
Portable: Java programs can run on any device with a compatible JVM.
High Performance: Uses Just-In-Time (JIT) compilation to optimize runtime performance.
Dynamic: Supports dynamic loading and linking of classes at runtime.
Distributed Computing: Facilitates network-based applications with built-in libraries for communication and data exchange.


Sample Program 
--------------------
package com.example.helloworld; // Package declaration

import java.io.*; // Imports all classes from the java.io package
import java.util.Date;  // Imports only Date class from java.util 
import static java.example.calculate; // import static method 

public class HelloWorld { // Class definition
    // Main method
    public static void main(String[] args) {
        System.out.println("Hello, World!");
		new Date(); // util
		new java.sql.Date(); // sql inline package declaration 
    }
}


Explaination
==============
package :  Declares the package to which this class belongs. Packages are used to group related classes and avoid name conflicts.

import: Imports classes from the java.util package. The * is a wildcard that includes all classes from this package.

class: The class contains the data and methods to be used in the program. Methods define the behavior of the class. Class GFG has only one method Main in JAVA.

static void main(): static keyword tells us that this method is accessible without instantiating the class.

void: keywords tell that this method will not return anything. The main() method is the entry point of our application.

System.in: This is the standard input stream that is used to read characters from the keyboard or any other standard input device.

System.out: This is the standard output stream that is used to produce the result of a program on an output device like the computer screen.

println(): This method in Java is also used to display text on the console. It prints the text on the console and the cursor moves to the start of the next line at the console. The next printing takes place from the next line.

String []args: This is the argument passed to the main function which is an array of strings with the array name args. One can choose their own flexible name but this name is used by many developers

Comments:

    - // Single line comment
    - /* Multi line comments*/


QUESTIONS
--------------------
1. Can we compile a java program without main() method?
	
2. Can we run a java program without main() method?
	
3.Can we overload and inherit main() method or not? 
 
4.Can we run main() method with following signatures 
	public static int main(String[] args)  {}  
	public static void Main(String[] args) {} 
	public static void main(String... args) {} 
	static public void main(String[] args) {}

5.What other keywords we can use with main() apart from public and static?

6.What should be the java filenaming convention, is it class name always?

7.What will be name bytecode or .classname, will it depends on filename or class name?

8.Can we write more than one class in a single java file?
	no of .class files == no classes 

9. if static block and main() method is used, which will be executed first?


VARIABLES IN JAVA
===========================
-> Variables are containers used to store data values. 
-> Each variable in Java has a type and a name, which determines what kind of data it can hold.
syntax:
	To create a variable, you must specify the type and assign it a value:
	type variableName = value;


RULES
-----------
1. Variable names can consists of letter (a-z, A-Z), digits (0-9), symbols (_, $).
2. 	Variable names (identifiers) must start with a letter (a-z, A-Z), underscore (_), or dollar sign ($). 
	They cannot start with a digit.
		Valid: age, _height, $value, num1
		Invalid: 1stPlace, @value, #data
3.	Variable names are case-sensitive. value, Value, and VALUE are considered different variables.
4.	Identifiers cannot be Java reserved keywords (e.g., int, class, public, static).
5.  Variables cannot have blank spaces 
	Invalid: String student name = "Surya"
	Valid: String studentName = "Surya"; //camel case for variables, methods
			String StudentName = "surya"; // pascal case for classes
			String student_name = "surya"; // snake case for constants
	
-> Java is a statically typed language, meaning the type of a variable is determined at compile-time and cannot change at runtime.
	Primitive Data Types:
		byte, short, int, long: Integer types of varying sizes.
		float, double: Floating-point types for decimal numbers.
		char: A single 16-bit Unicode character.
		boolean: Represents true or false values.
	Examples
		int count = 10;
		double price = 99.99;
		char grade = 'A';
		boolean isJavaFun = true;
	Reference Data Types:
		Include objects and arrays. 
		They refer to instances of classes and are created using new. 
	Examples:
		String name = new String("John Doe");
		int[] numbers = new int[5];

Types:
=============
- Where we declare?
- What is Scope?
- What is LifeTime?
- How to access ?

Local Variables: 
	Declared within a method or a block and can only be accessed within that method or block.
Instance Variables: 
	Declared within a class but outside any method. 
	They are accessible to all non-static methods of the class and have a lifespan corresponding to the instance of the class.
	They are bounded to object
Class Variables (Static Variables): 
	Declared with the static keyword and are shared among all instances of the class. 
	They belong to the class rather than any particular object.

Lifetime: 
	The lifetime of a variable is how long it exists in memory. 
	Local variables exist only during the execution of the method or block they are in. 
	Instance variables exist as long as the object they belong to exists. 
	Class variables exist as long as the class is loaded.

Default Values for variables 
--------------------------------
Default Values: Instance and class variables are automatically initialized with default values if not explicitly initialized:
    int â†’ 0
    double â†’ 0.0
    boolean â†’ false
    char â†’ \u0000 (null character)
    Object references â†’ null


JAVA DATA TYPES 
#################
- Defines the types of data to hold in variables.
- In Java, data types are classified into two main categories: primitive data types and reference data types.
=> Primitive Data Types
	- Primitive data types are the most basic data types provided by Java. 
	- They represent simple values and are not objects. 
	- Java has eight primitive data types:
	formula: -2^n-1  --> + (2^n-1 ) -1, here n is numbers of bits
  1. byte 
		Size: 8 bits (1 byte)
		Range: -128 to 127
		Default Value: 0
		Usage: Useful for saving memory in large arrays and when working with raw binary data.
			byte age = 25;
  2. short
		Size: 16 bits (2 bytes)
		Range: -32,768 to 32,767
		Default Value: 0
		Usage: Used to save memory in large arrays when the range of values is known to be small
			short year = 2024;
  3. int
    Size: 32 bits (4 bytes)
    Range: -2^31 to 2^31-1
    Default Value: 0
    Usage: The most commonly used integer type for general-purpose calculations.
		int population = 1000000;

  4. long
    Size: 64 bits (8 bytes)
    Range: -2^63 to 2^63-1
    Default Value: 0L
    Usage: Used when a wider range than int is needed, such as for large counters or timestamp calculations.
		long distance = 9876543210L;

  5. float
    Size: 32 bits (4 bytes)
    Range: Approx. Â±3.40282347E+38F (6-7 significant decimal digits)
    Default Value: 0.0f
    Usage: Used for floating-point arithmetic with single precision.
		float temperature = 98.6f;
 6. double
    Size: 64 bits (8 bytes)
    Range: Approx. Â±1.79769313486231570E+308 (15-16 significant decimal digits)
    Default Value: 0.0d
    Usage: Used for floating-point arithmetic with double precision
		double pi = 3.141592653589793;

 7. char
    Size: 16 bits (2 bytes)
    Range: 0 to 65,535 (Unicode characters)
    Default Value: '\u0000' (null character)
    Usage: Represents a single 16-bit Unicode character
		char initial = 'A';

 8. boolean
    Size: Not precisely defined (often 1 bit)
    Range: true or false
    Default Value: false
    Usage: Represents true/false values, commonly used in conditions and flags.
	
=>  Reference Data Types
	- Reference data types are used to refer to objects and arrays. 
	- They store references (or memory addresses) to the actual data rather than the data itself
	- Includes: Classes, Interfaces, Arrays, Strings, enums

** NOTE ***
	-  All integer literals (whole numbers) are treated as int by default.
	- To explicitly specify a long literal, use the L or l suffix. 
			If you don't include a suffix, the literal is considered an int.
	- By default, all floating-point literals (decimal numbers) are treated as double in Java.
	- To explicitly specify a float literal, use the f or F suffix. 
			If you don't include a suffix, the literal is considered a double.
	
	Try this?
	
		float res = 5.0/2 ;
		s.o.pln(res)
		
JAVA TYPE CASTING
-------------------------                                                                                                                                                                                
	In Java, there are two types of casting
=>Primitive Type Casting
	1. Widening Casting (automatically) | Implicit :
		converting a smaller type to a larger type size 
		byte -> short -> char -> int -> long -> float -> double
		- Done by Jvm
		- No loss of data
		
		int myInt = 10;
		double myDouble = myInt; // Implicit casting from int to double

	2. Narrowing Casting (manually) | Explicit TypeCasting : 
		converting a larger type to a smaller size type 
		double -> float -> long -> int -> char -> short -> byte
		- Done by users
		- There will be loss of data. 
		
		double myDouble = 9.78;
		int myInt = (int) myDouble; // Explicit casting from double to int

=>Reference Type Casting
	- Reference type casting is used for converting between different reference types, 
			typically involving inheritance. 
	- This involves casting objects to different types within an inheritance hierarchy.
	
	Upcasting: 
		Casting a subclass object to a superclass type. 
		This is done automatically and safely because a subclass object is always an instance of its superclass.
		
		class Animal {}
		class Dog extends Animal {}

		Dog myDog = new Dog();
		Animal myAnimal = myDog; // Upcasting from Dog to Animal

	Downcasting: 
	  Casting a superclass reference to a subclass type. 
	  This requires an explicit cast and 
	  can lead to a ClassCastException if the actual object is not of the subclass type.
		
		Animal myAnimal = new Dog();
		Dog myDog = (Dog) myAnimal; // Downcasting from Animal to Dog


JAVA KEYWORDS 
#####################
Data Types
    byte - 8-bit integer.
    short - 16-bit integer.
    int - 32-bit integer.
    long - 64-bit integer.
    float - 32-bit floating-point.
    double - 64-bit floating-point.
    char - 16-bit Unicode character.
    boolean - True or false value.

2. Conditional & Selections
    if - Conditional statement.
    else - Alternative branch for if.
    else if - Additional condition in if-else statements.
    switch - Multi-way branch statement.
    case - A branch in a switch statement.
    default - Default branch in a switch statement.
    break - Exit from the switch or loop.
    continue - Skip the current iteration of a loop.

3. Looping & Statements
    for - Loop with initialization, condition, and increment/decrement.
    while - Loop with a condition.
    do - Loop that executes at least once, used with while.
    return - Exit from a method and optionally return a value.
    goto - Reserved but not used (historically for potential jump statements).

4. Class & Objects
    class - Declares a class.
    interface - Declares an interface.
    extends - Indicates inheritance from a superclass.
    implements - Indicates that a class implements an interface.
    new - Creates new objects.
    this - Refers to the current object instance.
    super - Refers to the superclass and its members.
    static - Defines class-level variables and methods.
	enum - Defines a set of named constants.

5. Inheritance
    extends - Inherits from a superclass.
    super - Accesses superclass members.

6. Exceptions
    try - Starts a block of code that will be tested for exceptions.
    catch - Catches exceptions thrown by the try block.
    finally - Block that executes after try and catch, regardless of exception.
    throw - Throws an exception manually.
    throws - Indicates that a method can throw exceptions.
   
7. Threads
    synchronized - Ensures that a block of code or method is accessed by only one thread at a time.
    volatile - Indicates that a variableâ€™s value will be modified by different threads.

8. Legacy
    abstract - Defines an abstract class or method.
    native - Specifies that a method is implemented in native code using JNI (Java Native Interface).
    transient - Prevents serialization of a variable.
    final - Defines constants or prevents inheritance and method overriding.

9. New Version (Java 5 and later)
    assert - Used for debugging purposes to make assertions.
    var (Java 10) - Local variable type inference.
    module (Java 9) - Defines a module in the module system.
    exports (Java 9) - Specifies packages to be accessible to other modules.
    requires (Java 9) - Declares dependencies on other modules.
    opens (Java 9) - Declares packages for deep reflection.
    provides and with (Java 9) - Declares service provider implementations.
    to (Java 9) - Specifies which modules can access opened packages.
    @interface - Declares an annotation.
    @ (Annotations) - Used to provide metadata to classes, methods, or fields (e.g., @Override, @Deprecated).
	
*** NOTE *** 
 - In Java, true, false, and null are not technically keywords.
 - but they are special literals that are integral to the language's syntax and semantic.
 
 
Operators in JAVA 
-------------------------
- Operators in Java are special symbols or keywords used to perform operations on variables and values. 
- They are fundamental to Java programming as they allow you to manipulate data and perform computations.

1. Arithmetic Operators
	int sum = 5 + 3; // sum is 8
	int difference = 5 - 3; // difference is 2
	int product = 5 * 3; // product is 15
	int quotient = 15 / 3; // quotient is 5
	int remainder = 15 % 4; // remainder is 3
		N > D : get remainder using division method 
		N == D : 0 
		N < D  : N
		Integer Numerator / 0 : ArithmeticException
		
	
OBSERVATIONS
--------------------
	DIVISION operation: 
	-----------------------
		Integer / Integer: Performs integer division (no remainder).
		Floating-Point / Floating-Point: Performs floating-point division (retains remainder).
		Integer / Floating-Point: Converts integer to floating-point and performs floating-point division.
		Division by Zero: Throws ArithmeticException for integer division; 
						  results in infinity  for floating-point division.
	Try this?
		5.0/ 0 --> Infinity
		-5.0/0 --> -Inf
		5.0/-0 --> Inf
		-5/0 -->  AE 
	MODULUS Operation 
	-----------------------
	Integer % Integer: Returns the remainder of the division. The resultâ€™s sign matches the dividend.
	Floating-Point % Floating-Point: Returns the remainder based on floating-point arithmetic rules.
	
	Integer Negative modulus: sign of the result depends on the sign of the (the numerator)
	Floating-Point Negative modulus: sign of the result depends on the sign of the (the numerator)
	
	Integer Modulus Zero: Modulus with zero in integer results in an ArithmeticException
	Floating-Point Modulus with Zero: If the divisor is zero in floating-point arithmetic, 
			the result is NaN (Not a Number), as division by zero in floating-point arithmetic doesn't throw an exception but instead results in undefined behavior

	
	=> Remainder = dividend - (divisor * (int) quotient)
	

	
	ex 10.5 % 3.2 
		=10.5 / 3.2 --> 3.28125 (Q)
		= 10.5 - (3.2 * 3) 
		= 0.8999
		
	Try this?
		10%3 -->  1
		-10%3 --> -1
		10%-3  --> 1
		10.5 % 3.2 --> 0.89 
		-10.5 % 3.2 --> -0.89
		10 % 0 --> AE
		10.5%0.0 --> NaN 
		
2.Relational Operators
Relational operators are used to compare two values
	boolean result = (5 == 3); // result is false
	boolean result = (5 != 3); // result is true
	boolean result = (5 > 3); // result is true
	boolean result = (5 >= 3); // result is true
	boolean result = (5 < 3); // result is false
	boolean result = (5 <= 3); // result is false
	boolean result = ('a' > 'A'); // result is true , 97 > 65 

Observation
----------------
	Integral Types (int, long, short, byte): Supported
	Floating-Point Types (float, double): Supported
	Character Type (char): Supported
	Boolean Type (boolean): Not supported for relational operations (only we can apply ==, !=)
	Reference Types (e.g., String, custom objects): 
							Use .equals() or compareTo() 


3.Logical Operators
Logical operators are used to combine multiple boolean expressions
	&& (Logical AND): Returns true if both operands are true.
	boolean result = (5 > 3) && (8 > 6); // result is true
	
	|| (Logical OR): Returns true if at least one operand is true.
	boolean result = (5 > 3) || (8 < 6); // result is true
	
	! (Logical NOT): Inverts the value of a boolean expression.
	boolean result = !(5 > 3); // result is false
	
Observations
-----------------
 - boolean Type: Logical operators (&&, ||, !, ^) are designed to work with boolean values.
 - Logical AND (&&) and logical OR (||) operators use short-circuit evaluation
 Short-Circuit AND (&&): 
   If the first operand is false, the second operand is not evaluated because the result will be false regardless of the second operand.
		boolean result = false && (someExpensiveMethod());  // someExpensiveMethod() is not called
		
 Short-Circuit OR (||): 
	If the first operand is true, the second operand is not evaluated because the result will be true regardless of the second operand.
		boolean result = true || (someExpensiveMethod());  // someExpensiveMethod() is not called

4.Bitwise Operators
----------------------------
Bitwise operators operate on the binary representation of numbers
	1.& (Bitwise AND): Performs a bitwise AND operation.
	int result = 5 & 3; // result is 1 (binary 0101 & 0011 = 0001)
	
	2.| (Bitwise OR): Performs a bitwise OR operation
	int result = 5 | 3; // result is 7 (binary 0101 | 0011 = 0111)

	3.^ (Bitwise XOR): Performs a bitwise XOR operation.
	int result = 5 ^ 3; // result is 6 (binary 0101 ^ 0011 = 0110)

	4.~ (Bitwise NOT): Inverts all the bits of the operand.
	int result = ~5; // result is -6 (binary 0101 becomes 1010 and interpreted as negative)
	
	5.<< (Left shift): Shifts bits to the left

	int result = 5 << 1; // result is 10 (binary 0101 << 1 = 1010)

	6.>> (Right shift): Shifts the bits of the integer to the right.
        It performs an arithmetic shift, which means it maintains the sign of the original number.
        For positive numbers, it fills the new bits on the left with zeros.
        For negative numbers, it fills the new bits on the left with ones, preserving the sign bit (i.e., the most significant bit).
	
	int result = 5 >> 1; // result is 2 (binary 0101 >> 1 = 0010)
	int a = -16 >> 2; 
		binary of -16 (32-bit signed integer) is 11111111 11111111 11111111 11110000.
		Applying -16 >> 2 results in 11111111 11111111 11111111 11111100 (which is -4 in decimal).

	7. >>> (Unsigned right shift): Shifts bits to the right without sign extension.
		It performs an unsigned shift, meaning it does not preserve the sign of the original number.
		It fills the new bits on the left with zeros, regardless of the original sign bit.
	
	int result = -16 >>> 2; // result is a large positive number due to unsigned shift
	-16, which in binary is 11111111 11111111 11111111 11110000.
	Applying -16 >>> 2 results in 00111111 11111111 11111111 11111100 (which is 1073741820 in decimal).
	


	
Observations
--------------
	1.int, long, short, byte: Supported for bitwise operations. 
	2.Note that short and byte are promoted to int when performing bitwise operations, and you may need to cast back to short or byte if needed.
	3.float, double, boolean: Not supported for bitwise operations.
	Try this? 
		short s1 = 10; // 00000000 00001010 in binary
		short s2 = 4; // // 00000000 00000100 in binary
		short andResult = (short)(s1 & s2);  // throws error without (short)
		short orResult =  (short)(s1 | s2); // throws error without (short)
	4. For postive numbers the result of >>> and >> will be same.
	5. << will be same as n * 2^bits 
	6. >> will be same as n / 2^bits 
	
Bitwise NOT or Complement
------------------------------------
	Positive numbers:
		1. apply complement take the sign 
			0 : +ve 
			1 : -ve 
		2. Again apply 2s complement on step-1 result 
		
		ex: int a = 9; 
			binary of 9: 01001
		
			- 01001 after complement is 10110 , here MSB :1 , it's negative 
			- again apply 2's complement on 10110 
				1's : 01001 
				+ 		 1
				----------------
					  01010  == 10 in decimal 
				----------------
		
		formula: -(n+1) 
				: - (9+1) : -10 
				
	Negative numbers:
	-------------------------
		int a = -9
		1. take the binary of +ve number 
			9: 0000 1001 
		2. convert into negative (apply 2's complement) 
			~ : 1111 0110 
			+ : 		1
			----------------
				1111 0111
			
			1111 0111 is representation of -9 in binary
		3. apply invert 
			~ 1111 0111 --> 0000 1000 : 8 in decimal 
		
		formula: -(n - 1)
				=-(-9-1) 
				= 9-1 -> 8
		
5. Assignment Operators
	= (Simple assignment): Assigns a value to a variable.
	int a = 5;
	
	+= (Add and assign): Adds the right operand to the left operand and assigns the result to the left operand.
	int a = 5;
	a += 3; // a is now 8
	
	-= (Subtract and assign): Subtracts the right operand from the left operand and assigns the result to the left operand.
	int a = 5;
	a -= 3; // a is now 2
	
	int a = 5;
	a *= 3; // a is now 15
	
	int a = 6;
	a /= 3; // a is now 2
	
	int a = 7;
	a %= 3; // a is now 1
	
6. Unary Operators
	+ (Unary plus): Indicates a positive value (typically redundant).
	int a = +5; // a is 5

	- (Unary minus): Negates the value.
	int a = -5; // a is -5

	++ (Increment): Increases the value by one. Can be prefix (++a) or postfix (a++).
		- Pre Increment: first increment, then use the value 
		- Post Increment: first use the value. then increment
	int a = 5;
	a++; // a is now 6
	
	-- (Decrement): Decreases the value by one. Can be prefix (--a) or postfix (a--).
		- Pre Decrement: first decrement, then use the value 
		- Post Decrement: first use the value. then decrement
	int a = 5;
	a--; // a is now 4
	
	! (Logical NOT): Inverts a boolean value (also used in logical operators).
	
7. Conditional (Ternary) Operator
	? : (Ternary): Evaluates a condition and returns one of two values.
	syntax:
		(exp1) ? exp2 : exp3
		
	int a = (5 > 3) ? 10 : 20; // a is 10
	
8. Instanceof Operator
	instanceof (Type check): 
	Returns true if the object is an instance of the specified class or subclass.
	boolean result = (myObject instanceof String); // true if myObject is an instance of String
	
	
Operator Precedence
=======================
- In Java, operator precedence and associativity determine the order in which operators are evaluated in expressions.
- Operator precedence defines the order in which operators are evaluated in an expression

1.Postfix Operators: (), [], . (method call, array access, member access)
2.Unary Operators: ++, -- (prefix), +, - (unary plus and minus), ! (logical NOT), ~ (bitwise NOT)
3.Multiplicative Operators: *, /, % (multiplication, division, modulus)
4.Additive Operators: +, - (addition, subtraction)
5.Shift Operators: <<, >>, >>> (left shift, right shift, unsigned right shift)
6.Relational Operators: <, >, <=, >= (less than, greater than, less than or equal to, greater than or equal to)
7.Equality Operators: ==, != (equal to, not equal to)
8.Bitwise AND: &
9.Bitwise XOR: ^
10.Bitwise OR: |
11.Logical AND: &&
12.Logical OR: ||
13.Ternary Operator: ? : (conditional)
14.Assignment Operators: =, +=, -=, *=, /=, %= (assignment and compound assignments)
15.Comma Operator: , (used to separate expressions)


Operator Associativity
---------------------------
- Associativity defines the order in which operators of the same precedence level are evaluated. 
- Operators can be left-associative, right-associative, or have no associativity
	int result = 5 - 3 + 2; // evaluated as (5 - 3) + 2
	int a, b, c;
	
	a = b = c = 10; // evaluated as a = (b = (c = 10))
	
	
	int result = 5 + 3 * 2 - 8 / 4; // 5 + 6 - 2 --> 9
	
	int result = (5 + 3) * (2 - 8) / 4; // 8 * -6/4 -- -48/4 --> 12













 
 
